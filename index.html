<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blur Pacman Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #startButton {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: yellow;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      z-index: 10;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <audio id="music">
    <source src="chips.mp3" type="audio/mpeg">
  </audio>

  <button id="startButton">
    Push here to start.<br>
    Use arrow keys or hold phone flat <br>
    with charging port to the right<br>
    and tilt to move.<br>
    No copyright. No rights reserved.
  </button>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const bgImage = new Image();
    bgImage.src = "dople.png";

    const music = document.getElementById("music");
    let musicStarted = false;
    let gameOver = false;
    let showHistory = false;
    let historyStartTime = null;

    const pacman = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 25,
      speed: 5,
      direction: "right",
      mouthOpen: true,
      mouthTimer: 0
    };

    let focusZones = [];
    let permanentZones = [];
    let dots = [];

    const spacing = 60;
    const dotDeblurRatio = 5 / 12;
    const overallBlur = 8; // WebGL radius; 8 is already strong visually
    const tiltThreshold = 5;

    let tiltX = 0;
    let tiltY = 0;

    // --- WebGL Gaussian Blur Engine ---
    let webglBlur = null;

    function createWebGLBlur(canvas, image) {
      const glCanvas = document.createElement("canvas");
      glCanvas.width = canvas.width;
      glCanvas.height = canvas.height;

      const gl = glCanvas.getContext("webgl", { premultipliedAlpha: false });
      if (!gl) {
        console.warn("WebGL not supported, falling back to no blur.");
        return null;
      }

      const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        varying vec2 v_texCoord;
        uniform sampler2D u_image;
        uniform vec2 u_resolution;
        uniform float u_radius;

        void main() {
          vec2 texel = 1.0 / u_resolution;
          vec4 color = vec4(0.0);
          float total = 0.0;

          // radius capped to 10 samples each direction
          float r = min(u_radius, 10.0);

          for (float x = -10.0; x <= 10.0; x++) {
            for (float y = -10.0; y <= 10.0; y++) {
              if (abs(x) > r || abs(y) > r) continue;
              float weight = exp(-(x*x + y*y) / (2.0 * r * r));
              color += texture2D(u_image, v_texCoord + vec2(x, y) * texel) * weight;
              total += weight;
            }
          }

          gl_FragColor = color / total;
        }
      `;

      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program link error:", gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      // Interleaved position (x,y) and texCoord (u,v)
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([
          -1, -1,  0, 0,
           1, -1,  1, 0,
          -1,  1,  0, 1,
           1,  1,  1, 1
        ]),
        gl.STATIC_DRAW
      );

      const a_position = gl.getAttribLocation(program, "a_position");
      const a_texCoord = gl.getAttribLocation(program, "a_texCoord");

      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 16, 0);

      gl.enableVertexAttribArray(a_texCoord);
      gl.vertexAttribPointer(a_texCoord, 2, gl.FLOAT, false, 16, 8);

      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      // Upload the image to the texture
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        image
      );

      const u_resolution = gl.getUniformLocation(program, "u_resolution");
      const u_radius = gl.getUniformLocation(program, "u_radius");
      const u_image = gl.getUniformLocation(program, "u_image");

      gl.uniform2f(u_resolution, glCanvas.width, glCanvas.height);
      gl.uniform1i(u_image, 0); // texture unit 0

      gl.viewport(0, 0, glCanvas.width, glCanvas.height);

      return {
        canvas: glCanvas,
        render(radius) {
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.uniform1f(u_radius, radius);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          return glCanvas;
        }
      };
    }

    for (let x = spacing; x < canvas.width; x += spacing) {
      for (let y = spacing; y < canvas.height; y += spacing) {
        dots.push({ x, y, eaten: false });
      }
    }

    bgImage.onload = () => {
      webglBlur = createWebGLBlur(canvas, bgImage);
      // Optional: draw once initially
      if (webglBlur) {
        const blurred = webglBlur.render(overallBlur);
        ctx.drawImage(blurred, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      }
    };

    music.addEventListener("ended", () => {
      showHistory = true;
      historyStartTime = Date.now();
    });

    const historyText =
`Pac‑Man made its debut in 1980 — Namco released it in Japan in May of that year,
and it quickly spread worldwide, becoming one of the most iconic arcade games ever.

The TV show CHiPs, about California Highway Patrol officers Ponch and Jon,
originally aired from 1977 to 1983 on NBC.

PaCHiPs, designed to tantalizingly reveal the handsome and rugged looks
of two LA boys - one from West Covina, the other Echo Park - 
was released in 1982, thus missing out on the show's momentum.

The poor timing of Pac‑Man’s PaCHiPs (and later E.T. the Extra‑Terrestrial)
destroyed consumer trust, retailers slashed prices, 
warehouses filled with unsold stock, Atari posted massive losses.

By 1983, the company’s reputation was in tatters,
the wider market collapsed under the weight of too many consoles and low‑quality games.

Atari, once the fastest growing company in the U.S., 
was split and sold off by its parent Warner Communications in 1984,
marking the collapse of the studio that had defined the early console era.`;

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // WebGL blurred background (fallback: unblurred if no WebGL)
      if (webglBlur) {
        const blurred = webglBlur.render(overallBlur);
        ctx.drawImage(blurred, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      }

      const now = Date.now();

      // Permanent deblur zones
      permanentZones.forEach(zone => {
        ctx.save();
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      });

      // Temporary focus zones
      focusZones = focusZones.filter(zone => now - zone.time < 3000);
      focusZones.forEach(zone => {
        const fade = 1 - (now - zone.time) / 3000;
        ctx.save();
        ctx.globalAlpha = fade;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius || pacman.size * 3, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      });

      // Draw dots
      dots.forEach(dot => {
        if (!dot.eaten) {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Eat dots
      dots.forEach(dot => {
        if (!dot.eaten) {
          const dx = pacman.x - dot.x;
          const dy = pacman.y - dot.y;
          if (Math.sqrt(dx * dx + dy * dy) < pacman.size) {
            dot.eaten = true;
            permanentZones.push({
              x: dot.x,
              y: dot.y,
              radius: spacing * dotDeblurRatio
            });
          }
        }
      });

      if (!gameOver && !showHistory) {
        let xSpeed = Math.abs(tiltX) > tiltThreshold ? tiltX / 5 : 0;
        let ySpeed = Math.abs(tiltY) > tiltThreshold ? tiltY / 5 : 0;

        xSpeed = Math.max(Math.min(xSpeed, 10), -10);
        ySpeed = Math.max(Math.min(ySpeed, 10), -10);

        pacman.x += xSpeed;
        pacman.y += ySpeed;

        // Keep Pac-Man inside the screen
        pacman.x = Math.max(pacman.size, Math.min(canvas.width - pacman.size, pacman.x));
        pacman.y = Math.max(pacman.size, Math.min(canvas.height - pacman.size, pacman.y));

        if (xSpeed > 0) pacman.direction = "right";
        else if (xSpeed < 0) pacman.direction = "left";
        else if (ySpeed > 0) pacman.direction = "down";
        else if (ySpeed < 0) pacman.direction = "up";

        if (xSpeed !== 0 || ySpeed !== 0) {
          focusZones.push({
            x: pacman.x,
            y: pacman.y,
            time: Date.now(),
            radius: pacman.size * 3
          });
        }

        drawPacman();
      }

      if (showHistory) {
        const elapsed = now - historyStartTime;
        let alpha = 1;

        if (elapsed > 20000) {
          showHistory = false;
          gameOver = true;
        } else if (elapsed > 18000) {
          alpha = 1 - (elapsed - 18000) / 2000;
        }

        // Full-screen translucent background panel
        ctx.save();
        ctx.globalAlpha = alpha * 0.7;
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        // Black text
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "black";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";

        const lines = historyText.split("\n");
        let y = canvas.height * 0.10; // start nearer the top

        lines.forEach(line => {
          ctx.fillText(line, canvas.width / 2, y);
          y += 30;
        });

        ctx.restore();
      }

      if (gameOver && !showHistory) {
        ctx.fillStyle = "red";
        ctx.font = "bold 80px Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
      }

      requestAnimationFrame(gameLoop);
    }

    function drawPacman() {
      pacman.mouthTimer++;
      if (pacman.mouthTimer % 10 === 0) pacman.mouthOpen = !pacman.mouthOpen;

      ctx.fillStyle = "yellow";
      ctx.beginPath();

      let startAngle, endAngle;

      if (pacman.mouthOpen) {
        switch (pacman.direction) {
          case "right": startAngle = 0.25 * Math.PI; endAngle = 1.75 * Math.PI; break;
          case "left":  startAngle = 1.25 * Math.PI; endAngle = 2.75 * Math.PI; break;
          case "up":    startAngle = 1.75 * Math.PI; endAngle = 1.25 * Math.PI; break;
          case "down":  startAngle = 0.75 * Math.PI; endAngle = 2.25 * Math.PI; break;
        }
      } else {
        startAngle = 0;
        endAngle = 2 * Math.PI;
      }

      ctx.arc(pacman.x, pacman.y, pacman.size, startAngle, endAngle);
      ctx.lineTo(pacman.x, pacman.y);
      ctx.closePath();
      ctx.fill();
    }

    window.addEventListener("keydown", e => {
      if (gameOver || showHistory) return;

      if (!musicStarted) {
        music.play().catch(() => {});
        musicStarted = true;
      }

      switch (e.key) {
        case "ArrowUp": pacman.y -= pacman.speed; pacman.direction = "up"; break;
        case "ArrowDown": pacman.y += pacman.speed; pacman.direction = "down"; break;
        case "ArrowLeft": pacman.x -= pacman.speed; pacman.direction = "left"; break;
        case "ArrowRight": pacman.x += pacman.speed; pacman.direction = "right"; break;
        default: return;
      }

      // Keep Pac-Man inside bounds
      pacman.x = Math.max(pacman.size, Math.min(canvas.width - pacman.size, pacman.x));
      pacman.y = Math.max(pacman.size, Math.min(canvas.height - pacman.size, pacman.y));

      focusZones.push({
        x: pacman.x,
        y: pacman.y,
        time: Date.now(),
        radius: pacman.size * 3
      });
    });

    function enableTiltControls() {
      window.addEventListener("deviceorientation", e => {
        if (gameOver || showHistory) return;

        // Landscape orientation mapping: charging port to the right
        tiltX = (e.beta || 0);     // left/right tilt
        tiltY = -(e.gamma || 0);   // forward/back tilt
      });
    }

    document.getElementById("startButton").addEventListener("click", async () => {
      try {
        await music.play();
        musicStarted = true;
      } catch {}

      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          if (response === "granted") enableTiltControls();
        } catch {}
      } else if (/Mobi|Android/i.test(navigator.userAgent)) {
        enableTiltControls();
      }

      document.getElementById("startButton").style.display = "none";
      requestAnimationFrame(gameLoop);
    });
  </script>
</body>
</html>
